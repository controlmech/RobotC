//#pragma config(Sensor, S1,     soundSensor,    sensorSoundDBA)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float RADIUS = 2.75;
const int ONE_ROT_TICKS = 500; // see main
const int DIST = 15;
bool fire = false;

bool moveForward(int dist);
void turnLeft();
void turnAround();
void turnRight();
void turnBy(int ticks);

// Check for presence of IR beacon by wiggling the robot to check if the IR beacon is still on
// wiggleSpeed determines the direction of turning and wiggleAngle determines how much to turn
int fabs(int a)
{
	return (a > 0 ? a : a * -1);
}
int arr[1000]; // holds all distances travelled, if negative represents a rotation by that amount clockwise
int top = 0; // holds array index
void addElement(int a)
{
	arr[top] = a;
	top++;
}
void backToStart()
{
	turnAround();
	for (int i = top; i >= 0; i--)
	{
		if (arr[top] > 0)
			moveForward(arr[top]);
		else
			turnBy(arr[top] * -1);
	}
}
bool checkForIR(int wiggleSpeed, int wiggleAmount)
{
	bool present = false;

	motor[motorA] = motor[motorD] = 0;

	motor[motorA] = wiggleSpeed;
	motor[motorD] = -wiggleSpeed;
	nMotorEncoder[motorA] = 0;
	while (fabs(nMotorEncoder[motorA]) < wiggleAmount)
	{
		if (SensorValue[S2] != 0)
			present = true;
	}
	motor[motorA] = -wiggleSpeed;
	motor[motorD] = wiggleSpeed;
	while (fabs(nMotorEncoder[motorA]) > 0)
	{
		if (SensorValue[S2] != 0)
			present = true;
	}
	motor[motorA] = motor[motorD] = 0;
	return present;
}
bool isIRClose()
{
	// make sure to change IR mode to proximity
	if (SensorValue[S2] < 10)
		return true;
	return false;
}
// Operate motor for a certain amount of repetitions
void operateMotor(int repetitions, int motorSpeed, int motorRotationAmount, bool motorBBool)
{
	int motorNum = 0;
	if (motorBBool)
		motorNum = 1;
	else
		motorNum = 2;
		for (int count = 0; count < repetitions; count ++)
		{
			nMotorEncoder[motorNum] = 0;

			// Move the arm up and down
			if (motorSpeed > 0)
			{
				motor[motorNum] = -motorSpeed;
				while (nMotorEncoder[motorNum] > -motorRotationAmount)
				{}
				motor[motorNum] = motorSpeed;
				while (nMotorEncoder[motorNum] < 0)
				{}
			}
			else
			{
				motor[motorNum] = -motorSpeed;
				while (nMotorEncoder[motorNum] < motorRotationAmount)
				{}
				motor[motorNum] = motorSpeed;
				while (nMotorEncoder[motorNum] > 0)
				{}
			}
		}
		motor[motorNum] = 0;
}
void turnRight()
{
	int temp = SensorValue[S4];
  motor[motorA] = -20;
  motor[motorD] = 20;
  while(SensorValue[S4] < temp + (ONE_ROT_TICKS)/(float)(4)) // was previously (SensorValue[S4] < SensorValue[S4] + 90)
  {}
  motor[motorA] = motor[motorD] = 0;

  int netRotation = SensorValue[S4] - temp;
  if (netRotation > 0) // array stores negative numbers for rotations, positive is for moving forward
  	netRotation = ONE_ROT_TICKS - netRotation;
 	addElement(netRotation); // should just be -270
}
void turnLeft()
{
	int temp = SensorValue[S4];
  motor[motorA] = 20;
  motor[motorD] = -20;
  //resetGyro(S4);
  while(SensorValue[S4] > temp - (ONE_ROT_TICKS)/(float)(4))
	{}
  motor[motorA] = motor[motorD] = 0;
  int netRotation = SensorValue[S4] - temp;
    if (netRotation > 0) // array stores negative numbers for rotations, positive is for moving forward
    	netRotation = ONE_ROT_TICKS - netRotation;
   	addElement(netRotation); // sohuld just be -90
}
void turnAround()
{
	int temp = SensorValue[S4];
  motor[motorA] = -20;
  motor[motorD] = 20;
  //resetGyro(S4);
	while(SensorValue[S4] < temp + (ONE_ROT_TICKS)/(float)(2))
	{}
  motor[motorA] = motor[motorD] = 0;

  int netRotation = SensorValue[S4] - temp;
    if (netRotation > 0) // array stores negative numbers for rotations, positive is for moving forward
    	netRotation = ONE_ROT_TICKS - netRotation;
   	addElement(netRotation); // should just be -180
}
void turnBy(int ticks)
{
		int temp = SensorValue[S4];

    motor[motorA] = -20;
    motor[motorD] = 20;
    while(SensorValue[S4] < temp + ticks)
    {}
	  motor[motorA] = motor[motorD] = 0;

	  int netRotation = SensorValue[S4] - temp;
	  if (netRotation > 0) // array stores negative numbers for rotations, positive is for moving forward
	  	netRotation = ONE_ROT_TICKS - netRotation;
	 	addElement(netRotation);
}
bool moveForward(int dist)
{
    int temp = nMotorEncoder[motorD];
    motor[motorA] = motor[motorD] = 30;
    while((nMotorEncoder[motorD] - temp) < (dist * 180 / (PI * RADIUS)) && SensorValue[S3] > 5)
    {}
 		motor[motorA] = motor[motorD] = 0;

 		int displacement = (nMotorEncoder[motorD] - temp) * (PI * RADIUS) / 180;
   	addElement(displacement); // displacement will not equal dist if it stopped for a wall

  	if (SensorValue[S3] > 5)
  		return true;
  	else
  		return false;
}
void rotateToBeacon()
{
		wait1Msec(2000);
		int c = false;
		int temp = SensorValue[S4];
		//resetGyro(S4);
    // configure sensors
		if (SensorValue[S2] < 0)
		{
			motor[motorA] = 20;
   		motor[motorD] = -20;
		}
		else
		{
			motor[motorA] = -20;
   		motor[motorD] = 20;
		}

    while (fabs(SensorValue[S4]) <= 360 && !c)
    {
    	if (SensorValue[S2] <= 1 && SensorValue[S2] >= -1)
    		c = checkForIR(10,50) || checkForIR(-10,50);	// checks if the beacon is actually in front or just behind
    }
    motor[motorA] = motor[motorD] = 0;

    //check if backwards
    int tempEncoder = nMotorEncoder[motorD];
    motor[motorA] = -20;
    motor[motorD] = 20;
    while (nMotorEncoder[motorD] < temp + 50) // turn a little
    {}
  	if (SensorValue[S2] < 0) // correct orientation by turning 180
  	{
	  	int end = SensorValue[S4] + 180;
	  	motor[motorA] = -20;
	  	motor[motorD] = 20;
	  	while (SensorValue[S4] < end)
	  	{}
  	}
		motor[motorA] = 20;
    motor[motorD] = -20;
    while (nMotorEncoder[motorD] > temp)
    {}
    motor[motorA] = motor[motorD] = 0;

    int netRotation = SensorValue[S4] - temp;
    if (netRotation > 0) // array stores negative numbers for rotations, positive is for moving forward
    	netRotation = 360 - netRotation;
   	addElement(netRotation);
}
void extinguish()
{
	bool tempPresent = checkForIR(10,50);
	bool present = checkForIR(-10,50);

	if (present || tempPresent)
		present = true;
	motor[motorB] = motor[motorC] = 0;

	if (present)
		rotateToBeacon();
	bool motorBBool = true;
	// Test operate motor function
	while (present)
	{
		if (present)
		{
			if (motorBBool)
				operateMotor(5,50,80, motorBBool);
			else
				operateMotor(10,-90,58, motorBBool);
			tempPresent = checkForIR(10,50);
			present = checkForIR(-10,50);

			if (present || tempPresent)
				present = true;
			else
				present = false;

			motorBBool = !motorBBool;
		}
	}
	fire = false;
  backToStart();
}
void search()
{
	while (fire)
	{
		rotateToBeacon();
		if (!moveForward(100)) // goes until hits a wall or until 1 meter
		{
			bool obstacle = true;
			while(obstacle)
			{
				// basically tries to go around whatever is infront
				turnLeft();
				moveForward(DIST);
				turnRight();
				if (SensorValue[S3] > 5)
					obstacle = false;
			}
		}
		// should prolly set ir mode here or something
		if (isIRClose())
		{
			rotateToBeacon();
			extinguish();
		}
	}
}
task main()
{
	nMotorEncoder[motorD] = 0;
	SensorType[S2] = sensorEV3_IRSensor;
	SensorType[S3] = sensorEV3_Ultrasonic;
	SensorType[S4] = sensorEV3_Gyro;

	wait1Msec(2000);

	SensorMode[S2] = modeEV3IR_Seeker;
	SensorMode[S4] = modeEV3Gyro_RateAndAngle;

	rotateToBeacon();
	//SensorMode[S2] = modeEV3IR_Proximity;
	// Wait for sound
	/*
  while(SensorValue[S1] <= 90)
  {}
  fire = true;

 	search();
  backToStart();

  if (fire)
      displayString(0, "Job failed");
  else
      displayString(0, "Job successful");
*/
  // THE FOLLOWING TESTS HOW MANY TICKS ARE IN A FULL ROTATION
      /*
  int temp = SensorValue[S4];
  nMotorEncoder[motorA] = 0;
  motor[motorA] = -20;
  motor[motorD] = 20;
  while (SensorValue[S4] - temp < 360)
	{}
	int ticksInOneRotation = nMotorEncoder[motorA]; // value for constant defined at the top
	displayString(4, "ticks: %d", ticksInOneRotation);
  */

	//time1[T1] = 0;
	//while(time1[T1] < 10000)
	//{
	//	displayString(5,"%d", SensorValue[S2]);
	//	wait1Msec(1000);
	//	eraseDisplay();
	//}
	//SensorMode[S2] = modeEV3IR_Seeker;
	//extinguish();

	//moveForward(10);
	//turnAround();
	//rotateToBeacon();
	//while (SensorValue[S1] <= 90)
	//{}
	//extinguish();
}
